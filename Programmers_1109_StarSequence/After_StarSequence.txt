/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 11 / 09
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/70130
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 스타수열

다음과 같은 것들을 정의합니다.

어떤 수열 x의 부분 수열(Subsequence)이란,
x의 몇몇 원소들을 제거하거나 그러지 않고 남은 원소들이 원래 순서를 유지하여 얻을 수 있는 새로운 수열을 말합니다.

예를 들어, [1,3]은 [1,2,3,4,5]의 부분수열입니다. 원래 수열에서 2, 4, 5를 제거해서 얻을 수 있기 때문입니다.
다음과 같은 조건을 모두 만족하는 수열 x를 스타 수열이라고 정의합니다.

x의 길이가 2 이상의 짝수입니다. (빈 수열은 허용되지 않습니다.)
x의 길이를 2n이라 할 때,
다음과 같은 n개의 집합 {x[0], x[1]}, {x[2], x[3]}, ..., {x[2n-2], x[2n-1]} 의 교집합의 원소의 개수가 1 이상입니다.
x[0] != x[1], x[2] != x[3], ..., x[2n-2] != x[2n-1] 입니다.
예를 들어, [1,2,1,3,4,1,1,3]은 스타 수열입니다. {1,2}, {1,3}, {4,1}, {1,3} 의 교집합은 {1} 이고, 각 집합 내의 숫자들이 서로 다르기 때문입니다.
1차원 정수 배열 a가 매개변수로 주어집니다. a의 모든 부분 수열 중에서 가장 길이가 긴 스타 수열의 길이를 return 하도록 solution 함수를 완성해주세요.
이때, a의 모든 부분 수열 중에서 스타 수열이 없다면, 0을 return 해주세요.

제한사항
a의 길이는 1 이상 500,000 이하입니다.
a의 모든 수는 0 이상 (a의 길이) 미만입니다.
입출력 예
a	result
[0]	0
[5,2,3,3,5,3]	4
[0,3,3,0,7,2,0,2,2,0]	8
입출력 예 설명
입출력 예 #1

a의 부분 수열 중에서 주어진 조건을 모두 만족하는 스타 수열이 없으므로, 0을 return 해야 합니다.
입출력 예 #2

[5,2,5,3], [5,3,3,5] 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 4를 return 해야 합니다.
입출력 예 #3

[0,3,3,0,7,0,2,0] 는 a의 부분 수열인 동시에 스타 수열입니다. a의 부분 수열 중 이보다 더 긴 스타 수열은 없으므로, 8을 return 해야 합니다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

최대로 조건이 만족할 수 있는 숫자를 구한다.
1. A 에서 조건을 만족하는 가장 많은 수를 찾음.
2. 그 숫자를 기준으로 조건을 만족하는 갯수를 찾음
3. 찾은 갯수 * 2

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점

1. 내가 부분수열의 개념을 잘못 이해한듯하다.
ex) {1, 3, 1, 3} 에서 부분수열은 {1, 3}, {1, 3} 이 될 수 있다.
하지만 내가 생각했던건 {1, 3} == {1, 3} 이 같기 때문에, 해당 숫자를 카운트 할 수 없다고 정의하고 코드를 구현했다.
그래서 도중에 map 을 썼고 그 과정에서 몇 개의 알 수 없는 실패가 떴다.

정답이 된 알고리즘에 따르면, {1, 3, 1, 3} 이 주어졌을 때, {1, 3}, {1, 3} 으로 최대 길이는 '4' 가 된다.
또 문제에서 주어진 조건에는 {x[0] != x[1]}, {x[2] != x[3]}
즉, 두 개의 원소의 값이 다르기만 하면되는 거였다. {1, 3} 이 두번들어왔는지 신경쓰지 않아도 되었다.
내 욕심이겠지만, 문제에서 이런 부분을 예시로 주었으면 더 쉽게 풀었을 거 같다.

2. 가장 많이 나온 수를 기준으로 잡는 작업
{0, 0, 0, 0, 2, 3, 2, 3,} 이 있다고 가정할 때,
문제의 정답이 되는 알고리즘은 0 이 제일 많이 나왔고 그것을 기준으로 {0, 2} 가 되서 2 가 나온다.
하지만 제일 긴 수열은 {2,3}, {2,3} 으로써 4가 나와야되는데 이 부분은 문제에서 확인하지 않는 듯하다.
그래서 나는
제일 많이 나온다는 기준을 if(A[i - 1] != A[i] || A[i] != A[i + 1]) 로 조건을 주고 정의했다.
이 조건문을 추가하면 {2,3}, {2,3} 으로 4가 나온다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






