/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 05 / 11
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 카드 섞기 게임

카드게임이 있다. 게임에 사용하는 각 카드에는 양의 정수 하나가 적혀있고 같은 숫자가 적힌 카드는 여러 장 있을 수 있다.
게임방법은 우선 짝수개의 카드를 무작위로 섞은 뒤 같은 개수의 두 더미로 나누어 하나는 왼쪽에 다른 하나는 오른쪽에 둔다.

각 더미의 제일 위에 있는 카드끼리 서로 비교하며 게임을 한다. 게임 규칙은 다음과 같다.
지금부터 왼쪽 더미의 제일 위 카드를 왼쪽 카드로, 오른쪽 더미의 제일 위 카드를 오른쪽 카드로 부르겠다.

1. 언제든지 왼쪽 카드만 통에 버릴 수도 있고 왼쪽 카드와 오른쪽 카드를 둘 다 통에 버릴 수도 있다. 이때 얻는 점수는 없다.
2. 오른쪽 카드에 적힌 수가 왼쪽 카드에 적힌 수보다 작은 경우에는 오른쪽 카드만 통에 버릴 수도 있다.
오른쪽 카드만 버리는 경우에는 오른쪽 카드에 적힌 수만큼 점수를 얻는다.

3. (1)과 (2)의 규칙에 따라 게임을 진행하다가 어느 쪽 더미든 남은 카드가 없다면 게임이 끝나며,
그때까지 얻은 점수의 합이 최종 점수가 된다.
왼쪽 더미의 카드에 적힌 정수가 담긴 배열 left와 오른쪽 더미의 카드에 적힌 정수가 담긴 배열 right가 매개변수로 주어질 때,
얻을 수 있는 최종 점수의 최대값을 return 하도록 solution 함수를 작성하시오.

제한 사항
한 더미에는 1장 이상 2,000장 이하의 카드가 있다.
각 카드에 적힌 정수는 1 이상 2,000 이하이다.

입출력 예
left	right	return
[3, 2, 5]	[2, 4, 1]	7

입출력 예 설명
먼저 오른쪽 카드를 버려서 2점을 획득한다.
그 뒤 왼쪽 카드를 두 장 버리고 오른쪽 카드를 버려서 4점을 획득한다.
마지막으로 오른쪽 카드를 버려서 1점을 획득한다.
총 얻을 수 있는 점수는 7점이다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1.DP 를 이용,
2차원 배열 DP 를 생성

2. 행 - left, 열 - right 상황에서,
오른쪽 열로 갈수 있는 상황은 left > right 이다.
만약 오른쪽으로 갈 수 있다면 기존의 i - 1 의 값을 더한 값을 DP 에 넣는다.
아니라면,
* 왼쪽 카드만 버렸을 떄,
* 왼 오른 쪽 카드 모두 다 버렸을 때,
경우의 값의 max 를 구해 해당 DP 에 넣는다.

이런식으로 DP 를 마지막까지 채우게 되면, 마지막 인수에 최대의 값이 나옴.


위에 설명한 것은 정방향으로 구한 것이고
*구현된 코드는 역방향으로 구한다.

정방향으로도 구할 수 있을 것이다.
만약 오른쪽으로 갈 수 없는 상황 이라면, 해당 뒤의 값들을 모두 0으로 집어 넣으면 될 것이다.
정방향으로 구할 때 DP 의 모든 값들을 채워넣기 위해 오른쪽으로 계속 갈 수 없는 상황에서도 
값을 계산했기 때문이다.
따라서, 오른쪽으로 계속 갈 수 없는 상황(left > right 가 아닌 상황) 들을 모두 0 처리하면
정방향으로도 구할 수 있다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

좀 많이 어려웠다.
우선 처음 짤 때 DP 를 쓰지 않고 오른쪽(right) 를 돌면서 왼쪽(left) 과 계속 비교해가는 형식으로
구현했었는데, if 문의 특성상 상황마다 정의하다보니 정의하지 않은 또 다른 특별한 상황에 대해서 구현이 필요할 때
매우매우 복잡해졌다.

결국엔 문제에 나와있는 DP 를 이용해야하는 것인데, 쉽지 않았다. DP를 재대로 이해하지 못했었나보다.
우선 DP 는 경우의 수를 구하는 것임은 분명하다.
주어진 경우의 수는 3가지이다.
오른쪽 카드만 버릴 때, 왼쪽 카드만 버릴 때, 왼쪽 오른쪽 카드 둘 다 버릴 때,
이 때, 오른쪽 카드만 버릴 때는 left > right 란 조건이 있고 그 외 나머지는 다른 경우의 수 2가지에 해당함

이것들을 활용해서 DP 를 채워 나간다.
DP 는 경우의 수의 집합이다. 문제의 최종 값은 최대 값 return 이기 때문에 해당 경우의 수에서 나올 수 있는 최대값이다.
따라서 DP 를 2차원으로 정의하고 left, right 인덱스를 통해 그 상황에 맞는 최대의 경우의 수를 DP 에 넣으면 된다.
결론적으로,
left 나 right 의 카드가 모두 없어질 때, 즉 DP 의 마지막 Index 가 우리가 구하고자하는 최대 값이 된다.

DP 를 이용함으로써 모든 경우의 수를 "한번에" 구할 수 있게 됨. 굉장히 효율적인 방법이다.
지금 배운 이 느낌으로, 문제를 더 풀어봐야 확실히 DP 를 활용할 수 있을 것 같다.

더 나아가서, 
DP 문제 라고 쓰여져있지 않는 상황에서 문제를 풀 때, DP 의 방법으로 풀어야겠다는 생각이 들 수 있는
나를 만드는 것이 목표이다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






