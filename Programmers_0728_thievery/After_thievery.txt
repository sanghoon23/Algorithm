/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 07 / 28
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 도둑질

도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.

image.png

각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.

각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.

제한사항
이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.
money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.

입출력 예
money	return
[1, 2, 3, 1]	4

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1. 첫번째 집을 선택하냐 안하느냐

2. 첫번째 집을 선택했을 때,
제일 마지막 인덱스는 들릴 수 없으므로 size - 1 만큼 돌고 

3. 첫번째 집을 선택하지 않았을 땐,
size 만큼 돌고 각각 배열을 채워가면서 계산한다.

4. 결과 - return max(Temp1[money.size() - 2], Temp2[money.size() - 1]);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

너무 오랜만에 풀었다. 그래서 재대로 맞았다..
dp 를 풀 땐 항상 무엇을 어떤식으로 저장시켜야할지 매우 고민이 된다.
이 문제는 여타 다른 문제에서 푼 이차원 배열을 쓰지 않았는데, dp 의 개념은 똑같다.
저장해가면서 해당 경우의 최댓값을 구할 수 있는 방법이다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






