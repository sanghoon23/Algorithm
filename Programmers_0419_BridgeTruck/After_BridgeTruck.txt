/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 04 / 19
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 다리를 건너는 트럭

트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 
모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 
다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.
※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.

예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.

경과 시간	다리를 지난 트럭	다리를 건너는 트럭	대기 트럭
0	[]	[]	[7,4,5,6]
1~2	[]	[7]	[4,5,6]
3	[7]	[4]	[5,6]
4	[7]	[4,5]	[6]
5	[7,4]	[5]	[6]
6~7	[7,4,5]	[6]	[]
8	[7,4,5,6]	[]	[]
따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.

solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다.
 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.

제한 조건
bridge_length는 1 이상 10,000 이하입니다.
weight는 1 이상 10,000 이하입니다.
truck_weights의 길이는 1 이상 10,000 이하입니다.
모든 트럭의 무게는 1 이상 weight 이하입니다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1. Timer 함수 구현, Vector(Length) 만큼 잡고 == (통로),
2. while() 문으로 Vector 변수 들을 Swap 시킨다.
3. 이 때, Vector(통로) 안에 있는 모든 총합 과 지나갈 트럭의 무게(Insert Value) 의 합이
다리 무게 (Weight) 보다 작으면 Vector 에 집어 넣고, 아니면 Timer 돌린다. (== Result)
4. Vector(통로) 안에 아무것도 없으면 while() break; 하면 되지만,
- "구현상" 마지막 Index 에는 다리 길이만큼 더했다. 이렇게 하면 총합 시간이 구해진다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

Queue 를 써서 구현해보려했는데, 문제는 통로에 있는 전체 값들을 구해서 다리 무게보다 작은지 큰지 비교해야 하는데
Queue 만으로는 부족했음. 많이 삽질하다가

그냥 Vector 로 Length 길이 만큼 잡고 통로를 구현.
whlie(1) 문으로 Timer 를 돌린다는 생각으로 구현.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

** Queue 사용.
//
int solution(int bridge_length, int weight, vector<int> truck_weights) {
    int answer = 0;
    int count = 0;
    int Time = 0; 
    int Truck_weight = 0;
    queue<pair<int, int>> truck_move;

    while (true)
    {
        if (weight >= Truck_weight + truck_weights.at(count))
        {
            truck_move.push(make_pair(truck_weights.at(count), bridge_length + 1 + Time));
            Truck_weight += truck_weights.at(count);
            count++;
        }

        if (count >= truck_weights.size())
        {
            answer = truck_move.back().second;
            break;
        }
        else
        {
            Time++;
            if (truck_move.front().second == Time+1)
            {
                Truck_weight -= truck_move.front().first;
                truck_move.pop();
            }
        }

    }

    return answer;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






