/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 10 / 16 - (수정_1021)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/68937
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 트리 트리오 중간값

n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다.

어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다.
임의의 3개의 점 a, b, c에 대한 함수 f(a, b, c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다.
트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다.
주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요.

제한 사항
n은 3 이상 250,000 이하입니다.
edges의 행의 개수는 n-1 입니다.
edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다.
v1, v2는 각각 1 이상 n 이하입니다.
v1, v2는 다른 수입니다.
입력으로 주어지는 그래프는 항상 트리입니다.
입출력 예
n	edges	result
4	[[1,2],[2,3],[3,4]]	2
5	[[1,5],[2,5],[3,5],[4,5]]	2


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

* 최대 거리를 찾아야 함.
최대 거리를 갖는 노드가 2개 이상이면 최대거리가 중간값이 되고,
2개 미만이면 그 전의 거리가 중간값이 된다.

0. 해당 노드에 연결된 간선을 정리하기 위해 Map 사용
1. BFS(Queue) 사용.
2. 최대 단계(거리) 를 구함.
3. 여기서 최대거리가 되는 노드를 찾아야함.
문제는 어디서부터 들어가야 최대 거리가 되는지 모름.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점

이전의 해결 방법의 문제점
1. 속도
2. 왜 3번이 돌아야되는지 알지 못했음.

*속도
- Map 을 썼다. 구지 맵을 써야되는 이유가 뭐였을까?
단순히 BFS 를 이용하기 위해서 썼는데, 오히려 시간이 더 걸린다.
왜냐하면 Map[Value] 값을 찾는데 부하가 더 걸린다.
오히려 
vector<int> Temp(n);
Temp[Value] 값을 찾는 것이 더 빠르다.
또한 총 갯수 N 도 주어진다.

즉, 사용할 순 있지만 더 빠른 속도를 원한다면 Map 을 쓸 이유가 없다.
그냥 vector<vector<int>> Temp 로 BFS 나, DFS 를 도는 것이 선명하고 현명하다.

*왜 3번이 도는가?
그 전의 나의 예상은 최대 2번이면 최대 길이를 찾을 수 있다고 생각했다.
그런데 역시나, 예외가 존재했다.

우리는 시작점을 모른다. 그래서 처음에 1부터 탐색을 시작한다. 그렇다면 맨 끝지점이 찾아지고
그 다음 탐색 시 최대의 거리가 나온다.
우리가 원하는 정답은 중간값이다.
그래서 2번째 탐색 시 최대길이를 가지는 수가 2 이상이면 최대길이를 리턴
2 미만 이면 즉 1개만 존재한다면 최대길이 - 1 을 리턴하면 된다.

문제는 1개만 존재한다고 생각하고 최대길이 - 1 을 리턴하면 안된다.
최대길이가 2개 이상일 경우가 있다.

ex)
[2, 1], [1, 3], [3, 4] [3, 5] 가 그 경우이다.
2번 돌리게 되면 마지막 노드는 2가 나오겠고 최대길이가 1개만 존재한다고 생각된다.
하지만 마지막 노드가 4와 5 일 경우 최대길이가 두개가 된다.
이해가 안되면 그림을 그려보자.

그래서 총 2번을 돌리고 난 후, 최대길이가 2개 이상인 경우에는 그대로 리턴하면되고
그렇지 않다면 한 번을 더 돌려야 한다...


*DFS, BFS 로 각각 짜보았다. 참고해보자.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
#define endl '\n'
#define pb push_back
#define ft first
#define sd second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define cpr(x) sort(all(x)), (x).erase(unique(all(x)), (x).end());

int N;
vector<vector<int>> adj;
vector<int> dst;

pii BFS(int start) {
    queue<pii> q;
    q.push({start, 0});
    vector<bool> vis(N, false);
    vis[start] = true;
    pii ret = {start, 0};
    while (q.size()) {
        auto tmp = q.front();
        q.pop();
        int cur = tmp.ft;
        int cnt = tmp.sd;
        if (cnt > ret.sd) {
            ret = {cur, cnt};
            dst.clear();
            dst.pb(cur);
        }
        else if (cnt == ret.sd)
            dst.pb(cur);
        for (auto &next: adj[cur]) {
            if (vis[next])
                continue;
            vis[next] = true;
            q.push({next, cnt + 1});
        }
    }
    return ret;
}

int solution(int n, vector<vector<int>> edges) {
    N = n;
    adj.resize(N + 1, vector<int>());
    int answer;
    for (auto &e: edges) {
        int a = e[0], b = e[1];
        adj[a].pb(b);
        adj[b].pb(a);
    }
    pii x = BFS(1);
    pii y = BFS(x.ft);
    if (dst.size() >= 2)
        return y.sd;
    pii z = BFS(y.ft);
    if (dst.size() >= 2) {
        return y.sd;
    } else if (dst.size() == 1) {
        return y.sd - 1;
    }
    return -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






