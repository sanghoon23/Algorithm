/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 10 / 16
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/68937
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 트리 트리오 중간값

n개의 점으로 이루어진 트리가 있습니다. 이때, 트리 상에서 다음과 같은 것들을 정의합니다.

어떤 두 점 사이의 거리는, 두 점을 잇는 경로 상 간선의 개수로 정의합니다.
임의의 3개의 점 a, b, c에 대한 함수 f(a, b, c)의 값을 a와 b 사이의 거리, b와 c 사이의 거리, c와 a 사이의 거리, 3개 값의 중간값으로 정의합니다.
트리의 정점의 개수 n과 트리의 간선을 나타내는 2차원 정수 배열 edges가 매개변수로 주어집니다.
주어진 트리에서 임의의 3개의 점을 뽑아 만들 수 있는 모든 f값 중에서, 제일 큰 값을 구해 return 하도록 solution 함수를 완성해주세요.

제한 사항
n은 3 이상 250,000 이하입니다.
edges의 행의 개수는 n-1 입니다.
edges의 각 행은 [v1, v2] 2개의 정수로 이루어져 있으며, 이는 v1번 정점과 v2번 정점 사이에 간선이 있음을 의미합니다.
v1, v2는 각각 1 이상 n 이하입니다.
v1, v2는 다른 수입니다.
입력으로 주어지는 그래프는 항상 트리입니다.
입출력 예
n	edges	result
4	[[1,2],[2,3],[3,4]]	2
5	[[1,5],[2,5],[3,5],[4,5]]	2


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

* 최대 거리를 찾아야 함.
최대 거리를 갖는 노드가 2개 이상이면 최대거리가 중간값이 되고,
2개 미만이면 그 전의 거리가 중간값이 된다.

0. 해당 노드에 연결된 간선을 정리하기 위해 Map 사용
1. BFS(Queue) 사용.
2. 최대 단계(거리) 를 구함.
3. 여기서 최대거리가 되는 노드를 찾아야함.
문제는 어디서부터 들어가야 최대 거리가 되는지 모름.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;
using pii = pair<int, int>;
#define endl '\n'
#define pb push_back
#define ft first
#define sd second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define cpr(x) sort(all(x)), (x).erase(unique(all(x)), (x).end());

int N;
vector<vector<int>> adj;
vector<int> dst;

pii BFS(int start) {
    queue<pii> q;
    q.push({start, 0});
    vector<bool> vis(N, false);
    vis[start] = true;
    pii ret = {start, 0};
    while (q.size()) {
        auto tmp = q.front();
        q.pop();
        int cur = tmp.ft;
        int cnt = tmp.sd;
        if (cnt > ret.sd) {
            ret = {cur, cnt};
            dst.clear();
            dst.pb(cur);
        }
        else if (cnt == ret.sd)
            dst.pb(cur);
        for (auto &next: adj[cur]) {
            if (vis[next])
                continue;
            vis[next] = true;
            q.push({next, cnt + 1});
        }
    }
    return ret;
}

int solution(int n, vector<vector<int>> edges) {
    N = n;
    adj.resize(N + 1, vector<int>());
    int answer;
    for (auto &e: edges) {
        int a = e[0], b = e[1];
        adj[a].pb(b);
        adj[b].pb(a);
    }
    pii x = BFS(1);
    pii y = BFS(x.ft);
    if (dst.size() >= 2)
        return y.sd;
    pii z = BFS(y.ft);
    if (dst.size() >= 2) {
        return y.sd;
    } else if (dst.size() == 1) {
        return y.sd - 1;
    }
    return -1;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






