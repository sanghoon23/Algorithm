/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 11 / 23
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/17685
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 자동 완성

포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, go 가 한 번 입력되었다면, 다음 사용자는 g 만 입력해도 go를 추천해주므로 o를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다.
효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.

예를 들어, 학습된 단어들이 아래와 같을 때

go
gone
guild
go를 찾을 때 go를 모두 입력해야 한다.
gone을 찾을 때 gon 까지 입력해야 한다. (gon이 입력되기 전까지는 go 인지 gone인지 확신할 수 없다.)
guild를 찾을 때는 gu 까지만 입력하면 guild가 완성된다.
이 경우 총 입력해야 할 문자의 수는 7이다.

라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.

입력 형식
학습과 검색에 사용될 중복 없는 단어 N개가 주어진다.
모든 단어는 알파벳 소문자로 구성되며 단어의 수 N과 단어들의 길이의 총합 L의 범위는 다음과 같다.

2 <= N <= 100,000
2 <= L <= 1,000,000
출력 형식
단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.

입출력 예제
words	result
[go,gone,guild]	7
[abc,def,ghi,jklm]	4
[word,war,warrior,world]	15
입출력 설명
첫 번째 예제는 본문 설명과 같다.
두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.
세 번째 예제는 총 15 자를 입력해야 하고 설명은 아래와 같다.
word는 word모두 입력해야 한다.
war는 war 까지 모두 입력해야 한다.
warrior는 warr 까지만 입력하면 된다.
world는 worl까지 입력해야 한다. (word와 구분되어야 함을 명심하자)


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

*Trie 자료구조 구현.

0.Tree 구조체 & 함수 선언

-- 단어별로 Tree 형식으로 만들어진다. 이미 단어가 존재한다면 Tree 의 Number 를 늘려준다.
이제 단어별로 확인하는데, 그 단어의 개수가 1일 때까지 찾고 그 때, 단어의 몇번째 Index 까지 들어갔는지 확인하고
그 Index 가 자동완성문자의 최소 숫자이므로, Answer += val;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점

Trie 자료구조는 문자열 검색에서 많이 쓰여진다고 한다. 간단하게 구현해봤다.
사전과 비슷하게 Tree 형식으로 문자를 나누는 방식이다.
이렇게 되면 단어 탐색 시 찾고자하는 문자열의 길이가 속도가 될 것이다. O(n)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

*이 코드는 정렬 후, 단어를 비교하면서 찾아가는 방식이다.

#include <string>
#include <vector>
#include <algorithm>
int getReqNumofChar(const std::string &input, const std::string &adjWord)
{
    int len = input.length() > adjWord.length() ? adjWord.length() : input.length();
    for (int i = 0; i < len; i++)
    {
        if (input[i] != adjWord[i]) return i + 1;
    }
    return input.length() > len ? len +1 : len;
}
int getReqNumofChar(const std::string &input, const std::vector<std::string> &adjWords)
{
    return std::max(getReqNumofChar(input, adjWords[0]),
        getReqNumofChar(input, adjWords[1]));
}

int solution(std::vector<std::string> words)
{
    int answer = 0;
    sort(words.begin(), words.end());

    for (int i = 1; i < words.size() - 1; i++)
    {
        answer += getReqNumofChar(words[i], { words[i - 1], words[i + 1] });
    }
    answer += getReqNumofChar(words.front(), words[1]);
    answer += getReqNumofChar(words.back(), words[words.size() - 2]);
    return answer;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






