/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 10 / 19(수정)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/68938
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 문자열의 아름다움

어떤 문자열 x의 아름다움을 다음과 같이 정의합니다.

만약 x의 모든 글자가 전부 같다면, 0입니다.
그렇지 않다면, 서로 다른 글자가 위치해 있는 두 인덱스 i, j를 골랐을 때의 j-i 값들 중 최대값입니다.
예를 들어, 문자열 abbca의 아름다움은 3입니다. 인덱스 1(b)과 4(a)를 고르거나, 또는 0(a)과 3(c)를 고를 때 최대값이기 때문입니다.

영어 소문자로 이루어진 문자열 s가 매개변수로 주어집니다. s의 모든 부분문자열의 아름다움의 합을 return 하도록 solution 함수를 완성해주세요.

제한 사항
s의 길이는 1 이상 300,000 이하입니다.
입출력 예
s	result
"baby"	9
"oo"	0
입출력 예 설명
입출력 예 #1

다음 표는 baby의 각 부분문자열과 그 아름다움을 나타낸 것입니다.
인덱스 범위	부분문자열	아름다움
0 ~ 0	b	0
0 ~ 1	ba	1 (b, a 선택)
0 ~ 2	bab	1 (앞 b, a 선택 또는 a, 뒤 b 선택)
0 ~ 3	baby	3 (앞 b, y 선택)
1 ~ 1	a	0
1 ~ 2	ab	1 (a, b 선택)
1 ~ 3	aby	2 (a, y 선택)
2 ~ 2	b	0
2 ~ 3	by	1 (b, y 선택)
3 ~ 3	y	0
따라서, 각 부분문자열의 아름다움을 모두 더한 9를 return 해야 합니다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1. 만약 모든 문자열이 다를 경우, 총 합 구하기
2. 알파벳으로 분류하기.
3. 같은 알파벳이 몇 번 있는지를 구하고, 문자열이 연속되는 횟수 따로 구하기
4.
b a b y
a b y
b y ...

순으로 인덱스가 결정됨. 여기서 우린 같은 문자열일 때, 덜 세어지는 값을 구해서 총합에서 빼주면 됨.
babbb 시 -1, -2, -3
babb 시 -1, -2
bab 시 -1
연속적인 수가 됨. 따라서 count*count-1 / 2 가 됨.

* count*(count-1) / 2 값은 배열로 미리 구해놨음.

여기서 문제는 연속적으로 이어졌을 때 와 나뉘어서져 있을 때,
abbbb 일 때와 babbb 일 때 값을 구분해줘야함.

j 만큼 돌면서 (여기선 인덱스)
Alpha[i] 의 사이즈만큼 (최대 연속적이 될 수 있는 수) => s 를 돌 때,

ex) j = 0 -->> 문자열이 최대일 때, 덜 세어지는 수
Num += (s - j) * Continus[i][s] (연속적인 수의 갯수) 를 구함.
s (연속적인 수의 갯수) - j(인덱스) 가 음수인 경우는 필요없으므로 s = j + 1 부터 시작.

이렇게 구한 Num(count*(count - 1) / 2) 값을 빼줌.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점

* 시간 초과 문제
매우 힘들었다.
우선, 주어진 S 의 문자열을 두 번 돌면 무조건 시간초과발생한다.
주어진 문자를 알파벳순으로 정리하는게 핵심이었고 더불어서
정리를 한 후, abbb 와 babb 의 차이점을 알아야 했다.
이 때도 값이 너무 커서 계산이 너무 많이 들어가면 시간초과나기 때문에
최대한 계산을 줄이는 방식으로 짜야했다.
long long 으로 형변환 계산도 꼼꼼히 해줘야했다.

답은 쉽게 구할 수 있는지언정 속도를 줄이는게 관건인 문제였다.
그게 너무 어려웠다.

//@1019(수정)
코드를 바꾸었다.
밑에 코드가 속도가 빨라서 이해해보려고 했는데, 지금은 이해를 못하겠다.
굳이 이해하면서 시간을 쓰기보다는 다시 한번 코드를 수정해보려했다.

1. 기존 코드
	for (int i = 0; i < 26; ++i)
	{
		if (Alpha[i] <= 1) continue;
		for (int j = 0; j < Alpha[i]; ++j)
		{
			long long Num = 0;
			for (int s = j + 1; s <= Alpha[i]; ++s)
			{
				Num += (long long)(s - j) * Continus[i][s];
			}
			if (Num == 0) continue;

			Answer -= Sum(Num - 1);
		}
	}
	
이 부분을 단지 for 문을 줄이면 된다.

2. 수정 코드
		int Loop = Count;
		while (--Loop >= 0)
		{
			Continus[S[i] - 'a'][Loop] += Count - Loop;
		}
		
이 부분을 추가하면서,

	for (int i = 0; i < 26; ++i)
	{
		if (Alpha[i] <= 1) continue;

		for (int j = 0; j < Alpha[i]; ++j)
		{
			Answer -= Sum(Continus[i][j] - 1);
		}
	}

이렇게 바꾸었다.
** 기존 코드에선 무엇이 문제였는가? ** 
계산 횟수가 너무 많다.
이 문제 테스크케이스에서 엄청나게 큰 숫자가 오고가는거 같다.
그래서 계산횟수가 많을수록 더 시간이 오래 걸린다.

또 for 문을 한번 더 돌기 때문에 배로 증가한다.

단지 한꺼번에 계산한 것이다.
Answer += Sum(i) 부분도 기존 for 문에 같이 돌리고,
Continus 에서 연속된 숫자를 저장해서 다시 돌리면서 값을 구했다면,
수정 코드에선 미리 계산했다.
Sum(i) 값도 미리 Dp 로 구해놓았다.

문제는 for 문을 줄이기 위해 미리 계산할 방법인데,
우리가 구하고자하는 값은 총합 - (같은 문자열이라 줄어들 인덱스 ) 이다.
첫번째로 같은 문자열이라 줄어들 인덱스 를 구하는 과정을 잘 이해해야한다.

예를 들어, ccabccc 라면
첫번째 문자 c 에서 전체 문자열 ccabccc 까지 줄어들 인덱스는 1+ 1+2+3
두번째 문자 c 에서 문자열 cabccc 까지 줄어들 인덱스는 1+2+3
이어서 a 에서 abccc 까지 줄어들 인덱스 0 패스
이어서 b 에서 bccc 까지 줄어들 인덱스 0 패스
이어서 c 에서 ccc 까지 줄어들 인덱스 1+2
이어서 c 에서 cc 까지 줄어들 인덱스 1
마지막 - X

다른 예를 들어 비교가 쉽게 cccabcc  라면
첫번째 문자 c 에서 전체 문자열 cccabcc 까지 줄어들 인덱스는 1+2 1+2
두번째 문자 c 에서 문자열 ccabcc 까지 줄어들 인덱스는 1+ 1+2
이어서 c 에서 cabcc 까지 줄어들 인덱스 1+2
이어서 a 에서 abcc 까지 줄어들 인덱스 0 패스
이어서 b 에서 bcc 까지 줄어들 인덱스 0 패스
이어서 c 에서 cc 까지 줄어들 인덱스 1
마지막 - X

마지막으로 ccccc 라면
1+2+3+4
1+2+3
1+2
1

결론적으로, 연속되어지는 문자가 몇 개인지 찾아야되고
중간에 ccabcc 처럼 완전히 연속되지지 않는다면 따로 계산을 해줘야한다.
이해하기 어렵지만,

나는 쉽게 생각하기 위해서 인덱스로 생각했다.
여기서는 (인덱스)i = 0; i < 문자의 총 갯수; 이다.

ccccc 에서
인덱스(0) - ccccc -> Sum(5)
인덱스(1) - cccc -> Sum(4)
...

cccabcc 에서
인덱스(0) - ccccc -> Sum(5)
인덱스(1) c(연속3) - 1 + c(연속2) - 1 = Sum(3)
인덱스(2) c(연속3) - 2 + c(연속2) - 1 = Sum(1)
인덱스(3) c(연속3) - 3 + c(연속2) - 3 = X
...

ccabccc 에서
인덱스(0) - ccccc -> Sum(5)
인덱스(1) c(연속2) - 1 + c(연속3) - 1 = Sum(3)
인덱스(2) c(연속2) - 2 + c(연속3) - 2 = Sum(1)
인덱스(3) c(연속2) - 3 + c(연속3) - 3 = X
...

Answer => 43

사실 위의 규칙이 정확히 어떤 이유에서 되는지는 잘 모르겠다.
원래 ccccc 라면 Sum(5) + Sum(4) + ... Sum(1) 일 텐데
cccabcc 라면 중간에 띄워져있기 때문에 당연히 줄어들 인덱스의 갯수는 적겠고,
하지만 이 때, Sum(5) 는 무조건 만들어진다. 그래서 총 갯수의 Sum(총갯수) 는 포함하고
나머지 인덱스를 이용해서 나머지 뺄 것을 구할 수 있는 것 같다.

이 규칙을 이용해서
		int Loop = Count;
		while (--Loop >= 0)
		{
			Continus[S[i] - 'a'][Loop] += Count - Loop;
		}
		
이 부분을 만들었다.
Count( 연속된 문자갯수 ) 에 Loop(인덱스) 를 계속 빼가면서 Continus 에 저장한다.

*최종
이 문제에 엄청난 시간을 쏟았다.
시간을 줄이기 위해 다양한 방법을 시도했는데 실패하고 그나마 통과한 코드도 굉장히 느렸다.
조금 생각을 바꾸고 규칙을 이용하니 사실 얼떨결에 됐다.
코드도 굉장히 빨라졌다.
실전에선 못 풀었다.
위에서 말한 저 규칙을 일단 찾는데에도 엄청난 시간이 걸렸다.
일일히 다 써보면서 했는데도 처음엔 찾지 못했다.
특히 연속된 문자 를 구하는 방법까지는 찾았는데, 그 뒤로 cccabcc 처럼 떨어져있는 것을 어떻게 계산할지 몰랐다.
이 문제를 풀기 위해선 저 규칙을 단번에  찾아야 풀 수 있을 것인데...
그럼 어떻게 쉽게 찾을 수 있을까?
그걸 알았으면 이 고생을 안했겠지?
마지막에 푼 것도 보면 그렇게 엄청 어려운 것도 아니었다.
정말 답답해서 다른 분들 코드도 풀어서 봤는데 더 어려웠다.
최근 푼 문제 중에 제일 어려웠다. 풀면서 계속 답답하고 시간초과까지 계속 뜨니까 정신 나가버릴 것 같았다.
그래도 늘 그래왔듯이 끝까지 했다. 마지막에 푼 것도 운이 좋았다.
푸니까 또 기분은 좋은데, 다음에 이런 문제가 나왔을 땐 어떻게 할 것인가.
잘 모르겠다. 그냥 진득히 잘...하는게 최선이지 않을까 싶다.
다만 한가지, 과정을 한번에 하는 쪽으로 바꾼다면 시간이 빨라진다. 항상 한번에 하는 쪽으로 되도록 생각하자.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
#define NM 300005
#define INF 0x7fffffff
#define FOR(i,n,m) for (int i=(n);i<=(m);i++)

long long dy[26], cnt[26], idx[30], alpha[NM], l[NM], r[NM];
long long tree[26][NM * 2][2], B;
void Update(int c, int idx, int v) {
    idx += B;
    tree[c][idx][0]++;
    tree[c][idx][1]+=v;
    idx /= 2;
    while (idx) {
        tree[c][idx][0] = tree[c][idx * 2][0] + tree[c][idx * 2 + 1][0];
        tree[c][idx][1] = tree[c][idx * 2][1] + tree[c][idx * 2 + 1][1];
        idx /= 2;
    }
}
pair<ll,ll> Find(int c, int l, int r) {
    l += B, r += B;
    ll res = 0, res2 = 0;
    while (l <= r) {
        if (l & 1) res += tree[c][l][0], res2 += tree[c][l][1], l++;
        if (!(r & 1)) res += tree[c][r][0], res2 += tree[c][r][1], r--;
        l >>= 1, r >>= 1;
    }
    return { res,res2 };
}
long long solution(string s) {
    long long ans = 0;
    int n = s.length();
    B = n - 1;
    ll same = 0;
    FOR(i, 0, n - 1) {
        ll temp = (ll)i * (i + 1) / 2;
        if (i >= 1 && s[i] == s[i - 1]) {
            same++;
        }
        else if (i>=1){
            FOR(j, 1, same + 1) {
                Update(s[i - 1] - 'a', j, j);
            }
            same = 0;
        }
        temp -= same * (same + 1) / 2;

        auto [leCnt, leSum] = Find(s[i] - 'a', 1, same + 1);
        ll total = tree[s[i] - 'a'][1][0];

        temp -= leSum;

        temp -= (same + 1) * (total - leCnt);

        ans += temp;
    }

    return ans;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






