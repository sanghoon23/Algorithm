/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 10 / 01
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/68938
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 문자열의 아름다움

어떤 문자열 x의 아름다움을 다음과 같이 정의합니다.

만약 x의 모든 글자가 전부 같다면, 0입니다.
그렇지 않다면, 서로 다른 글자가 위치해 있는 두 인덱스 i, j를 골랐을 때의 j-i 값들 중 최대값입니다.
예를 들어, 문자열 abbca의 아름다움은 3입니다. 인덱스 1(b)과 4(a)를 고르거나, 또는 0(a)과 3(c)를 고를 때 최대값이기 때문입니다.

영어 소문자로 이루어진 문자열 s가 매개변수로 주어집니다. s의 모든 부분문자열의 아름다움의 합을 return 하도록 solution 함수를 완성해주세요.

제한 사항
s의 길이는 1 이상 300,000 이하입니다.
입출력 예
s	result
"baby"	9
"oo"	0
입출력 예 설명
입출력 예 #1

다음 표는 baby의 각 부분문자열과 그 아름다움을 나타낸 것입니다.
인덱스 범위	부분문자열	아름다움
0 ~ 0	b	0
0 ~ 1	ba	1 (b, a 선택)
0 ~ 2	bab	1 (앞 b, a 선택 또는 a, 뒤 b 선택)
0 ~ 3	baby	3 (앞 b, y 선택)
1 ~ 1	a	0
1 ~ 2	ab	1 (a, b 선택)
1 ~ 3	aby	2 (a, y 선택)
2 ~ 2	b	0
2 ~ 3	by	1 (b, y 선택)
3 ~ 3	y	0
따라서, 각 부분문자열의 아름다움을 모두 더한 9를 return 해야 합니다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1. 만약 모든 문자열이 다를 경우, 총 합 구하기
2. 알파벳으로 분류하기.
3. 같은 알파벳이 몇 번 있는지를 구하고, 문자열이 연속되는 횟수 따로 구하기
4.
b a b y
a b y
b y ...

순으로 인덱스가 결정됨. 여기서 우린 같은 문자열일 때, 덜 세어지는 값을 구해서 총합에서 빼주면 됨.
babbb 시 -1, -2, -3
babb 시 -1, -2
bab 시 -1
연속적인 수가 됨. 따라서 count*count-1 / 2 가 됨.

* count*(count-1) / 2 값은 배열로 미리 구해놨음.

여기서 문제는 연속적으로 이어졌을 때 와 나뉘어서져 있을 때,
abbbb 일 때와 babbb 일 때 값을 구분해줘야함.

j 만큼 돌면서 (여기선 인덱스)
Alpha[i] 의 사이즈만큼 (최대 연속적이 될 수 있는 수) => s 를 돌 때,

ex) j = 0 -->> 문자열이 최대일 때, 덜 세어지는 수
Num += (s - j) * Continus[i][s] (연속적인 수의 갯수) 를 구함.
s (연속적인 수의 갯수) - j(인덱스) 가 음수인 경우는 필요없으므로 s = j + 1 부터 시작.

이렇게 구한 Num(count*(count - 1) / 2) 값을 빼줌.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점

* 시간 초과 문제
매우 힘들었다.
우선, 주어진 S 의 문자열을 두 번 돌면 무조건 시간초과발생한다.
주어진 문자를 알파벳순으로 정리하는게 핵심이었고 더불어서
정리를 한 후, abbb 와 babb 의 차이점을 알아야 했다.
이 때도 값이 너무 커서 계산이 너무 많이 들어가면 시간초과나기 때문에
최대한 계산을 줄이는 방식으로 짜야했다.
long long 으로 형변환 계산도 꼼꼼히 해줘야했다.

답은 쉽게 구할 수 있는지언정 속도를 줄이는게 관건인 문제였다.
그게 너무 어려웠다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

* 엄청 빠른 코드..

#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
typedef long long int ll;
typedef pair<int, int> pii;
#define NM 300005
#define INF 0x7fffffff
#define FOR(i,n,m) for (int i=(n);i<=(m);i++)

long long dy[26], cnt[26], idx[30], alpha[NM], l[NM], r[NM];
long long tree[26][NM * 2][2], B;
void Update(int c, int idx, int v) {
    idx += B;
    tree[c][idx][0]++;
    tree[c][idx][1]+=v;
    idx /= 2;
    while (idx) {
        tree[c][idx][0] = tree[c][idx * 2][0] + tree[c][idx * 2 + 1][0];
        tree[c][idx][1] = tree[c][idx * 2][1] + tree[c][idx * 2 + 1][1];
        idx /= 2;
    }
}
pair<ll,ll> Find(int c, int l, int r) {
    l += B, r += B;
    ll res = 0, res2 = 0;
    while (l <= r) {
        if (l & 1) res += tree[c][l][0], res2 += tree[c][l][1], l++;
        if (!(r & 1)) res += tree[c][r][0], res2 += tree[c][r][1], r--;
        l >>= 1, r >>= 1;
    }
    return { res,res2 };
}
long long solution(string s) {
    long long ans = 0;
    int n = s.length();
    B = n - 1;
    ll same = 0;
    FOR(i, 0, n - 1) {
        ll temp = (ll)i * (i + 1) / 2;
        if (i >= 1 && s[i] == s[i - 1]) {
            same++;
        }
        else if (i>=1){
            FOR(j, 1, same + 1) {
                Update(s[i - 1] - 'a', j, j);
            }
            same = 0;
        }
        temp -= same * (same + 1) / 2;

        auto [leCnt, leSum] = Find(s[i] - 'a', 1, same + 1);
        ll total = tree[s[i] - 'a'][1][0];

        temp -= leSum;

        temp -= (same + 1) * (total - leCnt);

        ans += temp;
    }

    return ans;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






