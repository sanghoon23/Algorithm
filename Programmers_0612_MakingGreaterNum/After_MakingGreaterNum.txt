/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 06 / 13
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 큰 수 만들기

어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다.
이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다.
number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중,
가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

제한 조건
number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
k는 1 이상 number의 자릿수 미만인 자연수입니다.
입출력 예
number	k	return
1924	2	94
1231234	3	3234



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

*재귀, Greedy 하게,

1. 몇개를 제거할 것인가.
2. 맨 앞자리 숫자부터 구한다.

* 항상 Index ~ k + 1 까지의 범위에서 계산되어진다.
이로 인해서 Max 값의 앞자리 숫자들은 자동적으로 제거됨을 취급.

Ex)
1924 에서 2개를 제거한다면,

현재 인덱스 -> 0
제거되어야할 갯수는 2개 -> 0 ~ (0 + 2) 까지의 인덱스 계산
192 계산 -> 최댓값 9를 구함.

현재 인덱스 -> 2 = 이전의 최댓값 9 인덱스(1) + 1
제거되어야할 갯수는 1개 -> 2 ~ (2 + 1) 까지의 인덱스 계산
24 계산 -> 최댓값 4을 구함.

이런 방식으로 재귀,
Index(현재인덱스) + k(제거되어야 할 갯수) 가 number 의 크기보다 작을 때까지 반복.

이 때,
1. k == 0 이면, 이미 다 제거가 되어서 뒤에 남아있는 숫자들을 구함.
2. k > 0 이면, 아직 제거되지 않은 것들이 남아있다는 뜻, 그러므로 뒤에 남아있는 숫자를 고려하지 않고 리턴.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

Greedy (탐욕) 알고리즘은 무엇을 말하고자 하는가 생각해보았다.
탐욕은 무조건 정확하고 바른 결과를 만들어내리란 보장은 없다.

그래서
만약 위의 문제를 DFS 로 푼다면 다양한 경우의 수를 비교해서 계산된 값을 정학하겠지만,
매우 느린다는 단점이 있다.

하지만, 
모두가 합리적으로 조건을 만족한다면 탐욕알고리즘은 비교적 간단하고 최선의 결과를 나타낼 수 있다는 것이 장점이다.

탐욕 알고리즘을 풀 때 모두가 만족하는 조건을 찾는 것이 중요할 것이다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

//@나와 방식은 비슷한데 매우 직관적으로 잘 짰다.

string solution(string number, int k) {
    string answer = "";
    answer = number.substr(k); 
    for(int i = k-1;i >=0;i--){
        int j = 0;
        do{
            if(number[i] >= answer[j]){
                char temp = answer[j];
                answer[j] = number[i];
                number[i] = temp;
                j++;
            }else{
                break;
            }
        }while(1);
    }



    return answer;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






