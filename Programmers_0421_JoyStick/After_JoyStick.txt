/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 04 / 22
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 조이스틱 이용해 이름 만들기.

문제 설명
조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동
예를 들어 아래의 방법으로 JAZ를 만들 수 있습니다.

- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
만들고자 하는 이름 name이 매개변수로 주어질 때, 
이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

제한 사항
name은 알파벳 대문자로만 이루어져 있습니다.
name의 길이는 1 이상 20 이하입니다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

* 문제를 잘보자 커서 왼쪽으로 이동에서 첫 번째 위치에선 왼쪽으로 이동하면 마지막 커서로 갈 수 있지만,
오른쪽으로 이동 시, 다시 처음 문자로 갈 수 있다는 조건은 없다.

따라서,
1. size 만큼 문자열 string 을 잡고, name 과 비교

2. Index 이용, StartIndex 는 항상 0.
- StartIndex = 0, EndIndex 를 이용해서, 정방향으로 EndIndex 까지 돌고,
EndIndex != size 않다면, 다시 되돌아가 왼쪽 커서를 이용해 오른쪽 끝 문자열로 이동.

3. for 문
* StartIndex ~ EndIndex 까지 (++i)
* Size ~ EndIndex 까지 (--j)

4. AlphaHandle 을 이용해서 두 문자를 비교 - (최소 이동 횟수를 리턴)

5. 정방향으로 돌 때, A 가 존재한다면, ( CheckA 함수 이용 )
만약 "JAZ" , EndIndex = 2 일 때, A 는 갈 필요가 없다.
따라서 Size ~ EndIndex for문을 돌기 전에 CurrentIndex 를 더해줌.

5. 
갈 수 있는 방향의 모든 값들을 찾고 Min 을 구함.
Ex)
1 - 2 - 3 - 4
1 - 2 - 3 - 2 - 1 - 4
1 - 2 - 1 - 4 - 3
1 - 4 - 3 - 2


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

처음에 Index 이용을 생각 못하고, 깊이 탐색으로 풀려고 했다.
너무 시간이 오래걸렸다. 그리고 깊이 탐색은 모든 경우의 수를 찾는 것인데,
이 문제는 방향성이 존재한다. 즉, 연속적이다.
나올 수 있는 경우의 수는 모든 경우의 수가 될 수 가 없었다.

아래 코드는 매우 간단하게 Alpha 를 계산해서 가져왔다.
내가 짠 AlphaHandle 대신에 map 으로 데이터를 저장한 것만 보자.

***** 답은 틀리다. *****
순차적으로 알파벳 계산하고,
ACount 를 뺐는데, 이렇게 하면 말 그대로 정말 순차적으로만 계산되어,
리턴 해서 최소값이 나오는 것을 구할 수 없다.
Ex)
"BBAAB" - 6 이 나와야하는데,
밑에 코드는 - 7 이 나온다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

***** 답은 틀리다. *****

using namespace std;

int solution(string name) {
    int answer = 0;
    map<char,int> m;
    m['A']=0;
    m['B']=1;
    m['C']=2;
    m['D']=3;
    m['E']=4;
    m['F']=5;
    m['G']=6;
    m['H']=7;
    m['I']=8;
    m['J']=9;
    m['K']=10;
    m['L']=11;
    m['M']=12;
    m['N']=13;
    m['O']=12;
    m['P']=11;
    m['Q']=10;
    m['R']=9;
    m['S']=8;
    m['T']=7;
    m['U']=6;
    m['V']=5;
    m['W']=4;
    m['X']=3;
    m['Y']=2;
    m['Z']=1;
    int a_count=0;
    for(int i=1;i<name.length();i++){
        if(name[i]!='A')
            break;
        a_count++;
    }
    for(int i=0;i<name.length();i++){
        answer+=m[name[i]];
    }
    answer+=name.length()-1-a_count;
    return answer;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






