/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 05 / 21
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 단어 변환

두 개의 단어 begin, target과 단어의 집합 words가 있습니다.
아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.

1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
2. words에 있는 단어로만 변환할 수 있습니다.
예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면
hit -> hot -> dot -> dog -> cog와 같이 4단계를 거쳐 변환할 수 있습니다.

두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때,
최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.

제한사항
각 단어는 알파벳 소문자로만 이루어져 있습니다.
각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.
words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.
begin과 target은 같지 않습니다.
변환할 수 없는 경우에는 0를 return 합니다.
입출력 예
begin	target	words	return
hit	cog	[hot, dot, dog, lot, log, cog]	4
hit	cog	[hot, dot, dog, lot, log]


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1. DFS
기본적으로 재귀를 이용한다.

* bCheck vector<bool> 만들고
words.size() 보다 크거나 CurrentStr == TargetStr 다면, N 값을 구함

* DFS 에서는 예외사항이 존재,
깊이 탐색으로 경로의 끝까지 가기 때문에 
for(int i = 0; ..)
{
bCheck[i] = true; 하고
DFS( .. ) 재귀를 탈 때, 이 DFS 함수 호출에서 "최소값이 나오리라는 보장" 은 없다.

*따라서 bCheck[i] = false; 를 다시 해주어야 함.
}

최소가 나오기 위해선
hot -> dot -> dog -> cog 가 되야하는데,

만약 false 를 안해주게 되면
hot-> dot -> dog -> lot -> log -> cog 로 재귀를 먼저 돌게 되면
bCheck 가 false 이기 때문에

dog -> cog 를 지나치게 됨. 이 부분 유의해야함.

항상 DFS 에선 그 재귀 호출에 맞는 값이 유지되어야 함.

//////////////////////////////////////////////////////////////

2. BFS

queue <pair<string, int>> 를 사용함.
첫 번째 요소 begin 을 queue 에 넣고,
queue 가 비지 않을 때까지 돌린다.

DFS 처럼 false 를 안해주어도
BFS 는 queue 에서 꺼낸 값을 기준으로 돌기 때문에 
조건에 맞지 않는다면 넣지 않고, 맞는다면 바로 반환한다.

*BFS 는 꺼낸 값을 기준.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






