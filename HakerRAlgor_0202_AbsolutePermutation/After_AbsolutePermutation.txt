/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ HakerRanks Algorithm - 2020 / 01 / 22
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 절대값 문제

*필요한 식 : |pos[i] - i| = k

*Input : 
c(TestCase, 케이스 갯수), n(pos[n] 까지 들어있는 정수들의 집합), k(만들어질 Value)

*여기서 pos[i] 의 i(index) 는 1부터 시작.

위 절대값 식을 만족하는 것이 있으면, 출력하고,
아니라면, -1 을 출력


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

절대값인 걸 기억해라.
|pos[i] - i| = k 가 될 수 있는 절대값은 Min 과 Max 로 나뉜다고 생각함.
그래서,
struct Pair
{
	bool Max = false;
	int Result = 0;

	Pair(bool max, int result)
		: Max(max)
		, Result(result) {}
};
를 선언하고,

if(k==0) 이면 그대로 리턴.

순차적인 n 값을 이용해, Min,Max 를구하고, vector<Pair> 에 저장.
Max 가 n 을 초과 && Min 이 0 보다 작아지면 Fail(-1), (왜냐하면, pos[] 값의 Value는 마이너스가 업음.)
무슨 말이냐면, pos[i] - i  를 만족하는 값이 모두 n 까지의 정수에 해당되야함.
////////////////////////////////////////////////
Ex)
(1, 2, 3, 4) - n == 4 이고, k 가 == 2 라면
*****
1	3
2	4
3	1
4	2
////////////////////////////////////////////////

또한, 여기서 
*** 즉, 무조건 값이 하나밖에 선택될 수 없는 것만 vector<Pair> Calc 에 집어넣음 ***

for 문을 다 돌고 vector<Pair> Calc 를 계산.
Looping 재귀 함수를 이용함.
*void Looping(vector<int>* Vector, int k, int Num, bool Max)

Ex)
1 -> -1, 3 중 3 선택(Min) 으로 들어감
2 -> 0, 4 중 4 선택(Min) 으로 들어감
3 -> 1, 5 중 1 선택
4 -> 2, 6 중 2 선택

지금 예시에선 모두 다 값이 하나밖에 선택될 수 없지만, 값이 두개 다 모두 선택될 수 있을 때를 계산해야됨.
그러기 위해서 우선 무조건 선택될 수 있는 값을 선택해놓고 해당 값에 k를 빼거나 더하게 되면,
Input += k, Input -= k,
n 까지의 정수가 들어가게 됨. 항상 될 수 있는 경우는 저 규칙을 성립함.

마지막으로,
위에서  vector Result(n, -1) 로 초기화 해놓고,
해당 값에 -1 이 아직도 남아있다면, Fail
그렇지 않다면 return Result.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오
사실 한지 오래되서 기억이 잘..

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 느낀점
기억이 가물가물해서 코드를 보니까..
눈으로는 절대 이해안가고 손으로 써보니까 비로소 이해됐다.
역시 한번 풀어본거라, 어떤 느낌인지 몸이 기억하나보다.
근데 ... 좀 많이 복잡하네.. 그래도 그때는 , 이게 가장 쉬운방법이고 최선이었을 것이다.
자칫하다간 진짜 어려워진다..

밑에 코드 한번 분석해보자. 매우 간단하게 짜서 가져와봤따.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


vector<int> solve() {
	int n, k;
	cin >> n >> k;

	vector<int> a(n);
	for (int i = 0; i < n; i++) a[i] = i + 1;

	for (int i = 0; i < k; i++) {
		for (int j = i; j < n; j += k * 2) {
			if (j + k >= n) return{ -1 };
			swap(a[j], a[j + k]);
		}
	}

	return a;
}

int main() {
	int T;
	cin >> T;

	while (T--) {
		auto ans = solve();
		for (int i = 0; i < ans.size(); i++) printf("%d ", ans[i]);
		cout << endl;
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






