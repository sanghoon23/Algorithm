/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ HakerRanks Algorithm - 2020 / 01 / 23
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 3DSurfaceArea

네모(Box) 로 만들어진 Toy 장난감이 있다고 한다.
이 장난감에 가격을 매길려는데,
가격을 매기는 기준이

네모 정육면체의 각각 '보이는 면' 의 수 만큼 가격을 매긴다고 한다.

- Input
H, W  면적의 넓이 사이즈. Ex) 3, 3 이면 3x3 의 면적
A(i, j) 해당 HxW 에 해당하는 Box 의 개수이다.
무슨말이냐면,

Ex) Input 값으로
3, 3
1, 3, 4
2, 2, 3
1, 2, 4 

가 들어왔다고 가정하면,

3x3 의 행렬 위에 차례대로
1, 3, 4
2, 2, 3
1, 2, 4 의
박스들이 올라가 세워진다는 의미이다.

이제 여기서 총 육면체의 여섯 방향에서 보이는
면의 갯수를 Output 하면 된다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

1. surfaceArea(vector<vector<int>> A)
A 의 R(행), C(열) 을 구하고,

2. 윗면과 아랫면의 보이는 개수를 구한다.
R * C * 2  , 왜냐하면 위와 아래는 보이는 갯수가 동일하다.
문제는 측면과 앞뒷면이다.

3. 측면을 구하기 위해 먼저
HeightLine (최곳점) 을 설정한다.
이 최고점을 기준으로 계속 보이는 면을 계산해간다.
만약,
HeightLine = 0 과
2, 1, 3, 1, 4 로 나열된 박스에서 -->> 이 방향으로 보이는 개수를 구한다고하면

if (HeightLine < A[j][i])
{
RCalcNum += (A[j][i] - HeightLine);
HeightLine += (A[j][i] - HeightLine);
}
else if (HeightLine > A[j][i])
{
HeightLine = A[j][i];
}
즉,
HeightLine보다 값이 크면 Count 를 기존의 HeightLine 만큼 뺀 값을 증가시키고,
HeightLine보다 값이 작으면, 해당 높이가 곧 최고치가 되면서
증가되는 수만큼 계산되어져 간다.

4. 앞뒷면을 구한다. ( 측면과 동일하다. )

5. 앞면과 측면을 구한 값에 *2 를 해준다.
왜냐하면 앞면의 반대 뒷면도 동일하게 적용되서 값이 같다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

문제를 이해하는데 너무 많은 시간이 걸렸다.

처음엔 단지 보이는 면을 구하라고 해서 딱 봤을 때 보이는 면만 구하면서
계속 고민하다가..
2, 3 시간 만에 깨달았다.....
문장의 Showing 을 보지 못했다....

위 예시 처럼 만약,
2, 1, 3, 1, 4 라면 여기서 나는 보이는 면은 그냥 4라고 생각했는데,
문제에서 말하는 보이는 면이란,
2, 1 을 지나 3에서 (3 - 1) 의 면도 보이는 면이라고 칭했다...


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 느낀점

음...영어를 못하면 예시도 잘봤어야 했는데..
그러지 못했다. 계속 이상하다 이상하다.. 했는데 역시나 내가 잘못 이해한 것이다...
문제를 빨리 이해하는 것도 빨리 풀기 위한 필수이다..


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드

이 코드는,
다 돌면서 해당 차원의 박스의 총 갯수를 구하고,
작은 값들을 빼가는 방식으로 간단하게 구현.
즉,
for 돌면서 안보이는 면을 제거한 것이다.

1.
var tvolume=0;     
for(var i=0;i<A.Length;i++){
    for(var j=0;j<A[0].Length;j++){
        tvolume += (A[i][j]*4)+2;  // 해당 차원 박스 총 갯수.
        if(j>=1)tvolume -= Math.Min(A[i][j-1],A[i][j])*2;
        if(i>=1)tvolume -= Math.Min(A[i-1][j],A[i][j])*2;
    }
}
    return(tvolume);
}





