/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 07 / 06
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : 순위

n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다.
권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다.
심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.

선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때,
정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.

제한사항
선수의 수는 1명 이상 100명 이하입니다.
경기 결과는 1개 이상 4,500개 이하입니다.
results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.
모든 경기 결과에는 모순이 없습니다.

입출력 예
n	results										return
5	[[4, 3], [4, 2], [3, 2], [1, 2], [2, 5]]	2
입출력 예 설명
2번 선수는 [1, 3, 4] 선수에게 패배했고 5번 선수에게 승리했기 때문에 4위입니다.
5번 선수는 4위인 2번 선수에게 패배했기 때문에 5위입니다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

* 동적 프로그래밍의 활용 ( 이전의 값을 갱신하면서 저장 )

1. 2차원 배열 선언, 이겼으면 1, 졌으면 -1, 기록이 없으면 0

2. 이전의 선수에게 패배한 선수한테 패배했다면, 이전의 선수는 이 선수를 승리함.
예를 들어, 4 -> 3 -> 2 순이라면 4번 선수는 2번 선수를 이김.
이 원칙을 이용해서 2차원 배열에 1, -1 을 채워감.

3. for 문으로 해당 선수를 돌 때, 그 선수(현재)가 이긴 선수가 존재하면, 즉 1이 존재하면,
그 선수(1 존재하는) 는 이 선수(현재) 의 데이터가 전이됨.

4.
배열을 선언하고,
데이터를 집어넣고
3번에 해당하는 기준으로 데이터를 갱신

5. 이 때, 모든 데이터가 1, -1 로 채워져있다면 그 선수의 순위는 확답할 수 있음.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

처음엔 DFS 로 모든 경우의 수를 돌면서
방문횟수를 기준으로 순위를 확답하게 하였는데,
이런 기준은 애매하고, 연속적이지 않으면 불가능하다는 것을 알았다.

즉 위의 예제와 [1, 2], [2, 3], [3, 4], [4, 5] 예제는 가능하지만
만약 3등의 순위만 알 수 있는 상황이면??
예를 들어, 
n = 5 일 때,
[1, 3], [2, 3], [3, 4] [3, 5] 이라고 주어지면 답은 1인데 어떻게 답을 내야되나
굉장히 애매해진다.. 

한마디로, 확답을 할 수 있는 기준을 정확하게 잡지 못했다는 얘길 길게 썼다..

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 느낀점

늘 그렇지만 딱히 이렇다할 방법이 떠오르지 않을 땐 정말 미치겠다.
그렇다고 무턱대고 짤 순 없다.. 머리 속에 그려지지 않는 코드를 짜는건 사실 시간 낭비라고 생각한다..
처음엔 그냥 닥치고 짜보자! 하고 짜면 그 날은 헤어나올 수 없다. 만약 그것이 틀린 방향이라면,
그쪽 방향만으로의 생각으로 고정되어버리기 때문에
다른 쪽으로 돌리기 위해선 시간이 더 필요해진다.. 또 잘못된 것인데 로직 구현에 목을 매는 거 자체가 낭비이다.. 몸으로 많이 체험했다. 나만 그런건지 모르겠지만.
물론 그냥 무턱대고 짜다가 짜지는 것도 있고 번뜩 생각나는 것도 있는데,
그렇지 않을 경우가 많다..
항상 목적을 잃어버리지 않으려 노력하고 충분한 시간을 가지면서 그 목적에 부합하는 로직을 생각하는게 바람직하다.

사실 제일 베스트는 처음부터 잘 짜는 것이다.
문제를 보자마자 머리 속으로 선 이어지듯 그려지면서 코드가 저절로 타이핑되고 한번에 패스되는, 매우 이상적이지만 현실성은 약간 떨어지는 그런거.
다시 생각해보니, 첫 단추가 정말 중요하다고 느껴진다.
이 첫 단추를 잘 꼽으려면 어떻게 해야되나..

일단 여러 알고리즘을 본질을 알고 체득해야되고, 그것들 중에 어떤 것이 이 문제에 적용되어질 수 있는지
빠르게 판별하고 그것을 응용하는 것이다.
그러면 빠르게 판별하고 그것을 응용하려면 어떻게 해야되지..
...잘해야지..
그걸 할려고 알고리즘을 푸는 거다..
그런가.. 많이 풀면 되는건가?? 아니, 많이 생각하면 된다.
답을 내는데 익숙해지자.

그래도 처음 알고리즘 짠다고 허세부리면서 헤커랭크 문제를 무턱대고 무식하게 풀던 그때보다는 조금은 성숙해진 듯하다.
그 때는 함부로 코드부터 쳤는데, 이젠 함부로 코드 건들지 않는다. 그래도 모를 땐 함부로 건드는 것도 중요하다.
모두 조금씩 긍정적인 방향으로 좋아진 것 같고, 몸으로도 약간 체감이 된다.

내가 이렇게 조금 성숙해질 수 있었던 이유 중 하나는 포기하지 않았기 때문인 거 같다.
정확히 얘기하면 어차피 나중되면 풀어져있겠지, 잘 해결되어져 있겠지 라는 마음을 가지고 있었던거 같다.
신기하게 그렇게 생각하면 문득 해결방법이 떠오른다.
지금까지 내가 풀 수 있다고 생각한 것에서만큼은 못 푼 문제는 없다고 자부할 수 있다. 모두 완벽한 결과는 아닐지라도 흉내라도 내봤었던거 같다.
항상 이건 나밖에 못 푼다 라는 마음으로 생각이 안나면 날 때까지, 안되면 될 때까지 하면 되었으니까
이 마음 잊지 말고 더 정진하자!

이제 이 알고리즘 푸는 프로젝트를 한지도 이제 딱 반년 째이다.
쓰다보니 글이 길어졌는데, 다 쓰고보니 오른쪽 아래의 컴퓨터 달력을 보고 반년이란걸 알고 소름돋긴 했다.
남은 반년도 정신 없이 흐를 꺼 같다. 언리얼 프로젝트도 스퍼트 달리고 이력서 준비도 해야되고 할게 참 많다.
최근에 끝이 없다는 것에 대해서 회의감이 들고 무력감이 느껴졌었다. 언제까지 해야될까. 끝이 보이지가 않아 참 답답하고 힘들었는데
그냥 원래 끝이 없었다.
처음부터 끝이 없었던 거였다. 끝을 바란 내가 어리석었다. 원래 끝이 없다. 그렇게 생각하니 마음이 조금 편해졌다.
끝은 없지만 나의 목적지는 있다.
방금 생겼다. 나의 목적지는 "가상현실게임" 이다!....끝이 없다면 목적지도 끝이 없어야할 거 같았다..
너무 길어졌다. 이제까지 해왔던 것처럼 천천히, 꾸준히 앞으로 한 발자국씩 나의 목적지에 도달하자! 화이팅해라!


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






