/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ Programmers Algorithm - 2020 / 11 / 02
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//@링크 - https://programmers.co.kr/learn/courses/30/lessons/12952?language=cpp
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
- 문제이름 : N-Queen

가로, 세로 길이가 n인 정사각형으로된 체스판이 있습니다. 체스판 위의 n개의 퀸이 서로를 공격할 수 없도록 배치하고 싶습니다.

예를 들어서 n이 4인경우 다음과 같이 퀸을 배치하면 n개의 퀸은 서로를 한번에 공격 할 수 없습니다.

Imgur
Imgur

체스판의 가로 세로의 세로의 길이 n이 매개변수로 주어질 때,
n개의 퀸이 조건에 만족 하도록 배치할 수 있는 방법의 수를 return하는 solution함수를 완성해주세요.

제한사항
퀸(Queen)은 가로, 세로, 대각선으로 이동할 수 있습니다.
n은 12이하의 자연수 입니다.
입출력 예
n	result
4	2
입출력 예 설명
입출력 예 #1
문제의 예시와 같습니다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법

DFS
모든 경우를 다 도는 DFS 에서 어떻게 시간을 줄일 것인가.
필요없는 범위를 짤라줘야한다.
여기서 필요없는 부분은 첫번째 줄이 Queen 이 존재한다면,
그 줄은 DFS 할 필요가 없다. 해당 행의 갯수만큼 돌리면서
행의 갯수를 +1 씩 해가며 그 상황의 DFS 를 구한다.

예를 들어, 이전에
for(int j...)
	for(int i ...) if(Visisted[j][i] == true)continue; 로

모든 경우를 다 찾았다면, 이 경우엔
for(int i = Curr(현재행)..) if(Visted[Curr][i] ==.. && Find) 로 줄이고
또한, Find 함수를 따로 만들었다.

이전의 코드 참고.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오 & 느낀점

여기서 끝인가??
사실 시간이 너무 많이 걸린다.
그렇다면 더 줄일 수 있는 방법이 있나??
간단하게 우리는 for문을 최소화하면 된다.
Find 에서의 while 문을 최소화할 수 있다.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 다른 코드


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






