/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//@ HakerRanks Algorithm - 2020 / 01 / 14
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 문제
Queen Attack
- 장애물을 피해서 퀸이 갈 수 있는 곳의 개수 구하기.

들어오는 Input 값.
n 		- 보드 판의 길이 Ex) n = 5, 5 x 5 보드판
k 		- 장애물의 개수
r_q 	- Queen 의 행의 숫자
c_q		- Queen 의 열의 숫자
std::vector<std::vector>> obstacles[][] - 장애물 위치 2차원 배열.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 해결 방법
목적 : 주어진 보드판에서 퀸이 갈 수 있는 곳의 개수.

Ex)
	1, 2, 3, 4, 5,
1,
2,
3,
4,
5,
///////////////////// 이 상황일 때,

1. 가로 왼쪽 - 행이 같을 때, && r_q 보다 작을 때,
2. 가로 오른 - 행이 같을 때, && r_q 보다 클 때,
3. 세로 위쪽 - 열이 같을 때, && c_q 보다 작을 때,
4. 세로 아래 - 열이 같을 때, && c_q 보다 클 때,
5. 대각선 왼쪽 위 	- c_q 보다 작고 && r_q 보다 작을 때
6. 대각선 왼 아래 	- c_q 보다 작고 && r_q 보다 클 때,
7. 대각선 오른쪽 위 	- c_q 보다 크고 && r_q 보다 작을 때
8. 대각선 오른 아래 	- c_q 보다 크고 && r_q 보다 클 때,

총 8 방향의 최대 " 장애물 " 가까운 거리를 구했음.
해당 장애물 8개를 Enemys[] 에 집어넣고,
Queen 의 r_q 와 c_q 를 이용해서 각 방향 마다의 거리를 구한 다음,
ResultCount += 해주었음.


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 시행착오

내가 처음 생각한 시나리오는
Queen  갈 수 있는 전체의 개수를 구해서,
제일 가까운 장애물들을 구하고,
장애물들의 각 방향에 따라서 판에서의 거리를 구한다음

위에서 구한 전체의 개수에서 빼려고 시도했다.
전체의 개수는 구했다.
그런데, 문제는 장애물들의 거리를 "판에서" 구하려했기 때문에 어려웠다.
또한,
대각선 오른쪽에서 왼쪽으로 내려오는 값들은 합이 같은걸 찾아서
분기를 Sum(장애물) == r_q + c_q 로 주고,

대각선 왼쪽에서 오른쪽으로 내려오는 값들은 Queen 의 순서쌍 - 장애물 의 순서쌍 은 2의 배수인것을 찾아서
분기를 abs( (r_q + c_q) - Sum(장애물) ) % 2 == 0 로 주었다.

여기서의 문제는,
1. 저 분기에 해당하는 값들을 재대로 생각하지 못했다. 어줍잖은 분기보다 차라리 무식한 방법이 더 좋다.
	왜냐하면, 무식해도 정확하기 때문. 효율은 장담못하지만,
2. Input 값들을 재대로 활용하지 못했다.
	장애물의 거리를 구할 때, 
	Queen 과 장애물의 거리를 구하는 게 쉬울까.
	해당 방향에 제일 가까운 장애물들을 그 방향이 얼만큼 떨어졌는지 거리를 구하는게 쉬울까.
	
	순서대로 차근차근 구하는 것이 차라리 나을 수 있다.
	
사실 2 번이 문제는 아니었다. 1 번 문제점이 가장 컸다.
저 분기가 맞다고 믿고 있었기 때문에 오류를 못찾았다. 이미 % 2 = 0 이란 조건은 다른 순서쌍도 당연히 걸릴 수 있는 문제였다.

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// * 느낀점

주어진 값들을 재대로 활용하자.
어줍잖은 생각은 하지말자. 
저 분기(Sum == QueenSum) 보다 오른쪽 대각선 위를 구하는 분기(r_q 보다 작고 c_q 보다 큰) 가 더 좋다.

// 내가 짠 코드랑 차이점은,
// 나는 장애물 갯수만 돈다. for( 장애물 갯수 ) 만큼만 찾으면 된다.
// 밑의 예제는 재귀라, 하나하나 다 찾아간다. 결국 while 도는 것이다.
// 속도는 내가 짠 코드가 빠를거같다. 하지만, 밑의 코드가 간결하고 빨리 풀 수 있을 거 같다.



Ex) - 해커랭크에 dfs 를 이용해서 간결하게 짠 코드를 가져와봤다.
pair, 와 Set, Set 의 count 를 이용했다. 써먹을 수 있을거 같다.
해당 값(Pair) 가 존재하는 갯수를 리턴해주는 함수.

int ret;
set<pair<int,int>> obs;
int di[8] = {-1, -1, -1, 0, 1, 1, 1, 0};
int dj[8] = {-1, 0, 1, 1, 1, 0, -1, -1};
int n, k, a, b;

// @ Queen 이 계속 이동하면서 적이 없을 때까지 ( obs.count({ni, nj}) == 0 )
//   갈 수 있는 곳의 개수를 구하는 재귀함수를 씀.
//
//   Queen 위치에서 8방향 거리를 재귀를 돌린 것.
//   di, dj 방식은 참신하다..

void dfs(int a, int b, int k) // 재귀.
{
	int ni = a + di[k], nj = b + dj[k];
	if(ni >= 1 && ni <= n && nj >= 1 && nj <= n && obs.count({ni, nj}) == 0)
	{
		ret++;
		dfs(ni, nj, k);
	}
}

int main()
{
	scanf("%d %d", &n, &k);
	int si, sj;
	scanf("%d %d", &si, &sj); 		// 얘는 퀸의 위치
	while(k--) 						// 장애물 갯수만큼
	{
		scanf("%d %d", &a, &b);
		obs.insert({a, b}); 		// obs 에 Insert
	}

	for(int k = 0; k < 8; k++)		// 8방향 만큼 돌리기.
		dfs(si, sj, k);
	printf("%d\n", ret);
	return 0;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






